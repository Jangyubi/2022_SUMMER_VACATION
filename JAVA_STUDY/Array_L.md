# 220725 스터디 - 배열



## 1️⃣ 배열

> 배열이란? 동일한 자료형을 묶어 저장하는 참조 자료형을 말한다. 생성할 때 크기를 지정하고, 한 번 지정하면 변경할 수 없는 특징이 있다.
> 

---

### 배열 생성

```java
int[] a;
int a[];

double a[];
String[] a;
```



→ 배열 선언 시, 스택 메모리에만 변수가 선언. 스택 메모리에 선언된 자리는 실제 데이터 객체 값을 입력하지 않았으므로 빈 공간으로 남긴다.

- ❕ **자바의 메모리 구조**
    
    
    | 클래스 영역
    정적 영역
    상수 영역
    메서드 영역 | 스택 영역
    - 기본 자료형, 참조 자료형 모든 지역 변수가 위치하는 영역 | 힙 영역
    - 객체 공간
    - 참조 자료형 변수가 가리키는 실제 데이터 |
    | --- | --- | --- |

**(➕)**

⭐ **자료형[] 형식을 사용하는 이유는?**
⇒ 배열이 어떤 자료를 묶은 건지 알 수 있도록 명시함.

⭐ **null은 무엇을 의미하는가?**
⇒ 실제 데이터가 없다는 것을 나타냄.

---

### 배열 객체 생성

✅ 모든 참조 자료형의 실제 데이터(객체)는 힙 메모리에 생성되며, **‘new’** 키워드를 사용한다.

```java
new int[5];
new String[10];
```

(➕)

⭐ **배열의 길이를 지정하지 않으면 어떻게 되는가?**

⇒ 오류 발생

---

### 자료형 변수에 객체 대입

```java
int[] a = new int[3];

int[] a;
a = new int[3];
```

- 선언한 자료형의 형태만 배열 저장 가능
- a의 경우 실제 데이터 값이 아닌 데이터의 위치 값 저장
- **int[3]의 의미?** int 자료형 3개를 저장할 수 있는 공간을 힙 메모리에 저장하고, 저장한 위치를 a에 저장하라는 의미.


⭐ **스택 메모리 같은 경우에 값을 초기화 하지 않으면 null(빈 공간)상태이지만, 힙 메모리의 경우 초기화를 하지 않으면 자동으로 0으로 초기화가 된다.**

⇒ 기본 자료형일 때 숫자는 0, 0.0, 참/거짓을 나타내는 불리언은 false, 그 외 모든 자료형은 null값으로 정의된다.

```java
public class Main {
	public static void main(String[] args) {

	// 스택 메모리 변수 출력 오류
	int value;
	int[] value2;

	// 초기화
	int value = 0;
	int[] value2 = null;

	// 자동초기화
	int[] array = new int[3]';
	for(int i = 0; i < 3; i++) {
		System.out.println(array[i] + " ");
	}
```

⭐ **객체 위치를 참조 자료형에 저장하는 이유는?**

⇒ new 키워드로 객체 생성 후 힙 메모리 내에 비어있는 공간을 사용한다. 

1. **객체 생성과 값 대입**
    
    💫 초깃값 직접 넣는 방식
    
    ```java
    int[] array = new int[]{3, 4, 5}
    // 배열의 길이를 지정하지 않고, 넣는 초깃값의 갯수로 길이 결정
    
    int[] array = {3, 4, 5}
    // 대입 값만 입력하기
    ```
    
    **new int**[]를 생략한 두 번째 방법과 세 번째 방법은 완벽하게 동일하지 않다. 
    
    - ❓ 왜 동일하지 않을까?
        
        두 번째 방법은 변수 선언과 대입을 분리할 수 없다. 선언과 동시에 값을 대입할 때만 사용하므로 만약 메서드의 입력 변수 값으로 사용할 경우, 사용하지 않는다.
        
        ```java
        int[] a = new int[]{3, 4, 5};
        int[] a;
        a = new int[]{3, 4, 5} // 가능
        
        int[] a = {3, 4, 5}
        int[] a;
        a = {3, 4, 5} // 불가능
        ```
        
    
    ```java
    public class Main {
    	public ststic main void(String[] args) {
    	
    	// 첫번째 방법
    	int[] array1 = new int[3];
    	array1[0] = 1;
    	array1[1] = 2;
    	array1[2] = 3;
    
    	// 두번째 방법
    	int array2[];
    	array2 = new int[3];
    	array2[0] = 1;
    	array2[1] = 2;
    	array2[2] = 3;
    
    	// 세번째 방법
    	int array3;
    	array3 = new int[]{1, 2, 3};
    
    	// 네번째 방법
    	int array4[] = new int[]{1, 2, 3};
    
    	//다섯번째 방법
    	int array5[] = {1, 2, 3};
    
    ```
    
2. **참조 자료형 배열의 특징**
    
    변수 복사 예시 🔜 스택 메모리 값 복사 🔜 참조, 기본 자료형의 스택 메모리 값의 의미 차이 
    
    `기본 자료형` : 스택 메모리에 실제 데이터 값 저장
    
    ⇒ 복사하면 실제 데이터 값이 복사 되는 것이기 때문에 원본 값 영향 X
    
    `참조 자료형` : 스택 메모리에 실제 데이터의 위칫값 저장
    
    ⇒ 데이터의 위칫값이 이동하는 것이므로 데이터를 수정하면 복사한 데이터 값도 변하게 된다.
    
3. **배열 데이터 읽기(반복문), 길이** 

```java
// for문
public class Main {
	public static main void(String[] args) {

	int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	for(int i = 0; i < 10; i++) {
	System.out.println(array[i] + " ");
	}
}
}
	
// while문
public class Main{
  public static void main(String[] args) {

  int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9 ,10};
  int i = 0;

  while (i < 10) {
    System.out.print(array[i] + " ");
    i++;
  }
  }
}

// for-each문 : 집합 객체에서 원소들을 하나씩 꺼내 반복
public class Main{
  public static void main(String[] args) {
	int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9 ,10};
	  for (int k: array) { // 자료형 변수명: 집합 객체
	    System.out.println(k);
  }
}
}

// toString 메서드 사용
public class Main{
  public static void main(String[] args) {

	int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9 ,10};
	
	System.out.println(Array.toString(array));
} // 출력값 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

⭐ **배열 길이?** ⇒ `배열변수명.length`

`for(int i = 0; i < array.length; i++)`

`while (i < array.length)`

---

## 2️⃣ 2차원 정방 행렬

`int[행][열] a;`

 행⏬

열 ⏩

| a[0][0] | a[0][1] | a[0][2] | a[0][3] |
| --- | --- | --- | --- |
| a[1][0] | a[1][1] | a[1][2] | a[1][3] |
| a[2][0] | a[2][1] | a[2][2] | a[2][3] |

### 2차원 배열 선언

```java
int[행][열] a; // 권장

int a[행][열];

int[행] a[열];
```

➕) a[2][1] → 2차원 배열 a의 3번째 행과 2번째 열을 의미함

```java
int[][] array = new int[3][4];

int[][] array;
array = new int[3][4];

// int array[][], int[] array[] 방법 가능
```

### 2차원 배열 저장

⭐ **메모리는 2차원 데이터를 바로 저장할 수 없다. 실제 메모리는 1차원 형태의 데이터만 저장 가능하다.**


각각의 행이 1차원 배열 → 2차원 배열은 곧 1차원 배열을 요소로 포함하는 1차원 배열

1. **객체 생성 후 값 대입**

```java
int[][] a = new int[2][3];
a[0][0] = 1;
a[0][1] = 2;
a[0][2] = 3;
a[1][0] = 4;
a[1][1] = 5;
a[1][2] = 6;
```

| a[0][0] = 1 | a[0][1] = 2 | a[0][2] = 3 |
| --- | --- | --- |
| a[1][0] = 4 | a[1][1] = 5 | a[1][2] = 6 |

<aside>
💡 즉, 2차원 배열은 길이가 3인 1차원 배열 2개를 포함하고 있는 2차원 배열이라고 할 수 있다. 따라서 몇 차원의 배열이든 최종적으로 1차원 배열로 분할 가능하다.

</aside>


> **length 속성값**
> 

`a.length` ⇒ 2 (스택 메모리의 a 기준)

`a[0].length` ⇒ 3 (힙 메모리의 a[0]을 기준으로 했을 때의 기준)

`a[1].length` ⇒ 3 (`a[0].length`)와 동일

### 2차원 비정방 행렬 배열

⇒ 각 길이가 다른 2차원 배열을 말한다.


일반적으로 생성하는 행렬 방식 `int[][] a = new int[2][3]` 방식이 아닌 새로운 방식을 사용한다.

- **행 성분 생성 후 열 성분 생성**

```java
int[][] a = new int[2][];
a[0] = new int[2]; // 첫 번째 행의 열의 개수
a[1] = new int[3]; // 두 번째 행의 열의 개수
```

처음 객체를 생성 → 행 성분의 1차원 배열 생성 → 각 행 성분에 1차원 배열 할당 → 최종적으로 2차원 배열 객체 생성


- **자료형과 대입 값만 입력**

```java
int[][] a = new int[][] {{1, 2}, {3, 4, 5}}
// 배열의 길이는 쓰지 않음
// 순서대로 0번째, 1번째 ... 마지막 행 데이터
```

- **대입 값만 입력하기**

```java
int[][] a = {{1, 2}, {3, 4, 5}};

/* int[][] a;
a = {{1, 2}, {3, 4, 5}} (X) */
```

### 2차원 배열의 출력

- 가로, 세로 2개의 인덱스 사용 ⇒ 이중 for문

```java
int[][] a = {{1, 2}, {3, 4, 5}};

// 이중 for문
for(int i = 0; i < a.length; i++) { // 행의 개수
	for(int j = 0; j < a[i].length; i++) { // 열의 개수
		System.out.println(a[i][j]);
	}
}

// for-each문
for(int[] m: a) {
	for(int n: m) {
		System.out.println(n);
	}
}
```

## 3️⃣ 정리

1. 자바에서의 배열은 동일한 자료형을 묶어 저장하는 참조 자료형이며, 크기 지정 후 수정 불가능한 특징을 가지고 있다.
2. 1차원 생성 형태 : `자료형[] 변수명 = new 자료형[길이]` 
3. 기본 자료형과 참조 자료형은 실제 데이터 값이 저장된 메모리 위치가 다르다. 
    
    ⇒ 기본 : 스택 메모리 / 참조 : 스택 메모리에는 위칫값, 힙 메모리에 실제 데이터값
    
4. 1차원 배열 읽기는 for, while, for-each, toString 사용 가능하다
5. 배열의 길이 : `배열변수명.length`
6. 2차원 생성 형태 : `자료형[][] 변수명 = new 자료형[행][열]`
7. 2차원 배열은 1차원 배열을 요소로 포함하고 있는 1차원 배열
8. `2차원배열변수명.length` = 행 길이
9. `2차원배열변수명[i].length` = 열 길이